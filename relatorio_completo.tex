\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[margin=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}

% Configuração de cores
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuração do lstlisting
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Configuração de cabeçalho
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}
\lhead{Refatoração de Testes e Detecção de Test Smells}

\begin{document}

% Capa
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\LARGE\bfseries Pontifícia Universidade Católica de Minas Gerais\par}
    \vspace{0.5cm}
    {\large PUC Minas\par}
    \vspace{0.3cm}
    {\large Curso: Engenharia de Software\par}
    \vspace{0.3cm}
    {\large Disciplina: Teste de Software\par}
    \vspace{0.2cm}
    {\large Professor: Cleiton Tavares\par}
    
    \vspace{2.5cm}
    
    {\Huge\bfseries Refatoração de Testes e Detecção de Test Smells\par}
    
    \vspace{0.5cm}
    {\Large Trabalho Prático\par}
    
    \vspace{2.5cm}
    
    {\large
    \textbf{Aluno:} Luiz Nery\\
    }
    
    \vfill
    
    {\large \today\par}
\end{titlepage}

\tableofcontents
\newpage

% Introdução
\section{Introdução}

O presente trabalho tem como objetivo identificar, analisar e refatorar \textit{Test Smells} (maus cheiros em testes) em uma suíte de testes de software. \textit{Test Smells} são sintomas no código de teste que indicam problemas mais profundos, tornando os testes frágeis, obscuros, lentos e incapazes de detectar bugs de forma eficaz.

Utilizando ferramentas de análise estática como o ESLint, combinadas com análise manual, este trabalho demonstra como a qualidade dos testes pode ser significativamente melhorada através da aplicação de boas práticas e padrões como o \textit{Arrange, Act, Assert} (AAA).

\subsection{Contexto do Projeto}

O projeto base consiste em um serviço de gerenciamento de usuários (\texttt{UserService}), implementado em JavaScript/Node.js, com testes utilizando o framework Jest. A suíte de testes original (\texttt{userService.smelly.test.js}) foi deliberadamente escrita com diversos \textit{Test Smells} para fins didáticos.

\subsection{Objetivos}

\begin{itemize}
    \item Identificar manualmente diferentes tipos de \textit{Test Smells}
    \item Configurar ferramentas de análise estática para detecção automatizada
    \item Refatorar testes aplicando o padrão AAA e boas práticas
    \item Validar a melhoria através da eliminação de avisos do linter
    \item Demonstrar a importância de testes limpos para a sustentabilidade do software
\end{itemize}

\newpage

% Análise de Test Smells
\section{Análise de Test Smells Identificados}

Durante a análise da suíte de testes original, foram identificados cinco tipos distintos de \textit{Test Smells}, cada um com implicações específicas para a qualidade e manutenibilidade dos testes.

\subsection{Conditional Test Logic (Lógica Condicional em Testes)}

\textbf{Localização:} Teste ``deve desativar usuários se eles não forem administradores''

\textbf{Descrição:} Este smell ocorre quando testes contêm estruturas de controle de fluxo como loops (\texttt{for}, \texttt{while}) ou condicionais (\texttt{if}, \texttt{else}). O teste analisado utiliza um loop \texttt{for} para iterar sobre diferentes tipos de usuários e estruturas \texttt{if/else} para verificar comportamentos específicos.

\textbf{Riscos e Implicações:}
\begin{itemize}[noitemsep]
    \item Dificulta o entendimento do que está sendo testado
    \item Cria múltiplos caminhos de execução, tornando o teste imprevisível
    \item Alguns caminhos podem nunca ser executados
    \item Viola o princípio de responsabilidade única
    \item Quebra o padrão Arrange-Act-Assert
    \item Dificulta a identificação de falhas específicas
\end{itemize}

\textbf{Código Problemático:}
\begin{lstlisting}[language=JavaScript, caption=Teste com lógica condicional]
test('deve desativar usuarios se eles nao forem administradores', () => {
  const usuarioComum = userService.createUser('Comum', 'comum@teste.com', 30);
  const usuarioAdmin = userService.createUser('Admin', 'admin@teste.com', 40, true);
  const todosOsUsuarios = [usuarioComum, usuarioAdmin];

  for (const user of todosOsUsuarios) {
    const resultado = userService.deactivateUser(user.id);
    if (!user.isAdmin) {
      expect(resultado).toBe(true);
      const usuarioAtualizado = userService.getUserById(user.id);
      expect(usuarioAtualizado.status).toBe('inativo');
    } else {
      expect(resultado).toBe(false);
    }
  }
});
\end{lstlisting}

\subsection{Eager Test (Teste Ansioso)}

\textbf{Localização:} Teste ``deve criar e buscar um usuário corretamente''

\textbf{Descrição:} Um \textit{Eager Test} é aquele que testa múltiplas funcionalidades ou comportamentos em um único caso de teste. No exemplo identificado, um único teste verifica tanto a criação quanto a busca de usuários.

\textbf{Riscos e Implicações:}
\begin{itemize}[noitemsep]
    \item Reduz a granularidade dos testes
    \item Dificulta identificar qual funcionalidade falhou
    \item Mistura conceitos e responsabilidades diferentes
    \item Viola o princípio de responsabilidade única
    \item Torna os testes menos precisos e informativos
\end{itemize}

\subsection{Sensitive Equality (Igualdade Sensível)}

\textbf{Localização:} Teste ``deve gerar um relatório de usuários formatado''

\textbf{Descrição:} Testes que verificam detalhes muito específicos da implementação, particularmente formatação exata de strings, são considerados frágeis. Qualquer mudança cosmética na formatação quebra o teste, mesmo que a funcionalidade permaneça correta.

\textbf{Riscos e Implicações:}
\begin{itemize}[noitemsep]
    \item Alto acoplamento com detalhes de implementação
    \item Quebra facilmente com mudanças não funcionais
    \item Desencoraja refatoração
    \item Gera falsos negativos (teste falha mas funcionalidade está correta)
    \item Aumenta custo de manutenção
\end{itemize}

\subsection{Exception Handling (Tratamento Manual de Exceções)}

\textbf{Localização:} Teste ``deve falhar ao criar usuário menor de idade''

\textbf{Descrição:} O uso de blocos \texttt{try-catch} manuais para verificar exceções em testes é um anti-pattern. Se a exceção não for lançada, o teste passa silenciosamente, criando uma falsa sensação de segurança.

\textbf{Riscos e Implicações:}
\begin{itemize}[noitemsep]
    \item Teste pode passar mesmo quando deveria falhar
    \item Não garante que a exceção foi realmente lançada
    \item Código verboso e menos legível
    \item Dificulta a manutenção
\end{itemize}

\textbf{Código Problemático:}
\begin{lstlisting}[language=JavaScript, caption=Tratamento incorreto de exceções]
try {
  userService.createUser('Menor', 'menor@email.com', 17);
} catch (e) {
  expect(e.message).toBe('O usuario deve ser maior de idade.');
}
// Se a excecao nao for lancada, o teste passa silenciosamente!
\end{lstlisting}

\subsection{Disabled Test (Teste Desabilitado)}

\textbf{Localização:} Último teste com \texttt{test.skip}

\textbf{Descrição:} Testes comentados ou desabilitados representam código morto na suíte de testes e funcionalidades sem cobertura adequada.

\textbf{Riscos e Implicações:}
\begin{itemize}[noitemsep]
    \item Funcionalidade sem cobertura de testes
    \item Código morto no repositório
    \item Falsa sensação de cobertura
    \item Testes incompletos esquecidos indefinidamente
\end{itemize}

\newpage

% Configuração de Ferramentas
\section{Configuração da Ferramenta de Detecção Automatizada}

Para automatizar a detecção de \textit{Test Smells}, foi configurado o ESLint versão 9 com o plugin específico para Jest.

\subsection{Instalação das Dependências}

\begin{lstlisting}[language=bash, caption=Instalação do ESLint e plugin Jest]
npm install --save-dev eslint eslint-plugin-jest
\end{lstlisting}

\subsection{Configuração do ESLint}

O arquivo \texttt{eslint.config.js} foi criado com as seguintes configurações:

\begin{lstlisting}[language=JavaScript, caption=Configuração do ESLint v9]
import jest from 'eslint-plugin-jest';

export default [
  {
    files: ['**/*.js'],
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: {
        require: 'readonly',
        module: 'readonly',
        describe: 'readonly',
        test: 'readonly',
        expect: 'readonly',
        beforeEach: 'readonly',
      },
    },
    plugins: {
      jest,
    },
    rules: {
      ...jest.configs.recommended.rules,
      'jest/no-disabled-tests': 'warn',
      'jest/no-conditional-expect': 'error',
      'jest/no-identical-title': 'error',
    },
  },
];
\end{lstlisting}

\subsection{Regras Configuradas}

\begin{itemize}
    \item \textbf{jest/no-disabled-tests}: Alerta sobre testes desabilitados
    \item \textbf{jest/no-conditional-expect}: Proíbe expects dentro de condicionais
    \item \textbf{jest/no-identical-title}: Previne títulos duplicados em testes
\end{itemize}

\newpage

% Relatório da Ferramenta
\section{Relatório da Ferramenta de Análise Estática}

\subsection{Primeira Execução - Arquivo Original}

Ao executar o ESLint no arquivo original contendo os \textit{Test Smells}:

\begin{lstlisting}[language=bash, caption=Comando de análise]
npx eslint test/userService.smelly.test.js
\end{lstlisting}

\textbf{Resultado obtido:}

\begin{verbatim}
C:\Users\Nery\Documents\test-smelly\test\userService.smelly.test.js
  44:9  error    Avoid calling `expect` conditionally`  
                 jest/no-conditional-expect
  46:9  error    Avoid calling `expect` conditionally`  
                 jest/no-conditional-expect
  49:9  error    Avoid calling `expect` conditionally`  
                 jest/no-conditional-expect
  73:7  error    Avoid calling `expect` conditionally`  
                 jest/no-conditional-expect
  77:3  warning  Tests should not be skipped            
                 jest/no-disabled-tests
  77:3  warning  Test has no assertions                 
                 jest/expect-expect

✖ 6 problems (4 errors, 2 warnings)
\end{verbatim}

\subsection{Análise dos Resultados}

A ferramenta detectou automaticamente:

\begin{itemize}
    \item \textbf{4 erros} relacionados a expects condicionais (linhas 44, 46, 49, 73)
    \item \textbf{2 avisos} sobre teste desabilitado (linha 77)
    \item Total de \textbf{6 problemas} identificados
\end{itemize}

Estes resultados confirmam a análise manual realizada anteriormente, demonstrando a eficácia da ferramenta na detecção automatizada de \textit{Test Smells}.

\subsection{Segunda Execução - Arquivo Refatorado}

Após a refatoração completa:

\begin{lstlisting}[language=bash, caption=Validação do arquivo refatorado]
npx eslint test/userService.clean.test.js
\end{lstlisting}

\textbf{Resultado:} Nenhum problema encontrado (output vazio).

Este resultado comprova que todos os \textit{Test Smells} foram eliminados com sucesso.

\newpage

% Processo de Refatoração
\section{Processo de Refatoração}

\subsection{Metodologia Aplicada}

A refatoração foi conduzida seguindo os seguintes princípios:

\begin{enumerate}
    \item \textbf{Padrão AAA (Arrange-Act-Assert):} Estruturação clara de cada teste
    \item \textbf{Responsabilidade Única:} Um teste para cada comportamento
    \item \textbf{Nomes Descritivos:} Títulos que explicam o comportamento esperado
    \item \textbf{Eliminação de Lógica:} Remoção de loops e condicionais
    \item \textbf{Isolamento:} Testes independentes e autocontidos
\end{enumerate}

\subsection{Exemplo Detalhado de Refatoração}

\subsubsection{Código Original (Com Smells)}

\begin{lstlisting}[language=JavaScript, caption=Teste com múltiplos smells]
test('deve desativar usuarios se eles nao forem administradores', () => {
  const usuarioComum = userService.createUser('Comum', 'comum@teste.com', 30);
  const usuarioAdmin = userService.createUser('Admin', 'admin@teste.com', 40, true);
  const todosOsUsuarios = [usuarioComum, usuarioAdmin];

  for (const user of todosOsUsuarios) {
    const resultado = userService.deactivateUser(user.id);
    if (!user.isAdmin) {
      expect(resultado).toBe(true);
      const usuarioAtualizado = userService.getUserById(user.id);
      expect(usuarioAtualizado.status).toBe('inativo');
    } else {
      expect(resultado).toBe(false);
    }
  }
});
\end{lstlisting}

\subsubsection{Código Refatorado (Limpo)}

\begin{lstlisting}[language=JavaScript, caption=Testes refatorados seguindo AAA]
test('deve desativar usuario comum', () => {
  // Arrange
  const usuario = userService.createUser('Comum', 'comum@teste.com', 30);

  // Act
  const resultado = userService.deactivateUser(usuario.id);

  // Assert
  expect(resultado).toBe(true);
  const usuarioAtualizado = userService.getUserById(usuario.id);
  expect(usuarioAtualizado.status).toBe('inativo');
});

test('nao deve desativar usuario admin', () => {
  // Arrange
  const admin = userService.createUser('Admin', 'admin@teste.com', 40, true);

  // Act
  const resultado = userService.deactivateUser(admin.id);

  // Assert
  expect(resultado).toBe(false);
  const adminAtualizado = userService.getUserById(admin.id);
  expect(adminAtualizado.status).toBe('ativo');
});
\end{lstlisting}

\subsection{Decisões de Refatoração}

\begin{enumerate}
    \item \textbf{Separação de Cenários:} O teste original foi dividido em dois testes independentes, cada um focado em um único comportamento (desativar usuário comum vs. não desativar admin).
    
    \item \textbf{Eliminação de Lógica Condicional:} O loop \texttt{for} e as estruturas \texttt{if/else} foram completamente removidos, tornando o fluxo de execução linear e previsível.
    
    \item \textbf{Aplicação do Padrão AAA:} Cada teste agora segue claramente as três fases:
    \begin{itemize}
        \item \textbf{Arrange:} Preparação dos dados (criação do usuário)
        \item \textbf{Act:} Execução da ação (chamada de deactivateUser)
        \item \textbf{Assert:} Verificação dos resultados esperados
    \end{itemize}
    
    \item \textbf{Nomes Descritivos:} Cada teste possui um nome que descreve exatamente o comportamento esperado, sem ambiguidades.
    
    \item \textbf{Isolamento:} Os testes são completamente independentes e podem ser executados em qualquer ordem.
\end{enumerate}

\subsection{Outros Testes Refatorados}

\subsubsection{Correção do Exception Handling}

\textbf{Antes:}
\begin{lstlisting}[language=JavaScript]
try {
  userService.createUser('Menor', 'menor@email.com', 17);
} catch (e) {
  expect(e.message).toBe('O usuario deve ser maior de idade.');
}
\end{lstlisting}

\textbf{Depois:}
\begin{lstlisting}[language=JavaScript]
test('deve lancar erro quando usuario e menor de idade', () => {
  expect(() => {
    userService.createUser('Menor', 'menor@email.com', 17);
  }).toThrow('O usuario deve ser maior de idade.');
});
\end{lstlisting}

\subsubsection{Separação do Eager Test}

O teste original que verificava criação E busca foi separado em:

\begin{lstlisting}[language=JavaScript]
test('deve criar um usuario com dados validos', () => {
  const usuario = userService.createUser('Fulano', 'fulano@teste.com', 25);
  
  expect(usuario).toBeDefined();
  expect(usuario.id).toBeDefined();
  expect(usuario.nome).toBe('Fulano');
  expect(usuario.status).toBe('ativo');
});

test('deve retornar usuario quando ID existe', () => {
  const usuarioCriado = userService.createUser('Fulano', 'fulano@teste.com', 25);
  
  const usuarioBuscado = userService.getUserById(usuarioCriado.id);
  
  expect(usuarioBuscado).toBeDefined();
  expect(usuarioBuscado.nome).toBe('Fulano');
});
\end{lstlisting}

\newpage

% Resultados
\section{Resultados e Validação}

\subsection{Métricas Comparativas}

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Métrica} & \textbf{Arquivo Original} & \textbf{Arquivo Refatorado} \\
\hline
Número de testes & 5 & 14 \\
Problemas ESLint & 6 (4 errors, 2 warnings) & 0 \\
Test Smells identificados & 5 & 0 \\
Testes desabilitados & 1 & 0 \\
Padrão AAA aplicado & Parcial & 100\% \\
Lógica condicional & Sim & Não \\
\hline
\end{tabular}
\caption{Comparação entre arquivo original e refatorado}
\end{table}

\subsection{Execução dos Testes}

Todos os testes foram executados com sucesso:

\begin{verbatim}
PASS  test/userService.clean.test.js
PASS  test/userService.smelly.test.js

Test Suites: 2 passed, 2 total
Tests:       1 skipped, 18 passed, 19 total
Snapshots:   0 total
Time:        0.689 s
\end{verbatim}

\subsection{Benefícios Alcançados}

\begin{itemize}
    \item \textbf{Clareza:} Cada teste é autoexplicativo e fácil de entender
    \item \textbf{Manutenibilidade:} Alterações são mais simples e seguras
    \item \textbf{Confiabilidade:} Testes mais robustos e menos frágeis
    \item \textbf{Granularidade:} Melhor identificação de falhas específicas
    \item \textbf{Documentação:} Os testes servem como documentação viva do sistema
\end{itemize}

\newpage

% Conclusão
\section{Conclusão}

Este trabalho demonstrou na prática como \textit{Test Smells} comprometem significativamente a qualidade e eficácia de uma suíte de testes. Mesmo com cobertura de código adequada, testes mal escritos podem falhar em detectar bugs e criar uma falsa sensação de segurança.

\subsection{Principais Aprendizados}

\begin{enumerate}
    \item \textbf{Testes de qualidade vão além da cobertura:} A presença de \textit{Test Smells} torna testes ineficazes, independentemente da porcentagem de cobertura alcançada.
    
    \item \textbf{Ferramentas automatizadas são essenciais:} O ESLint demonstrou ser uma ferramenta valiosa para detecção automatizada de problemas, economizando tempo e garantindo consistência.
    
    \item \textbf{Padrões como AAA são fundamentais:} A aplicação rigorosa do padrão Arrange-Act-Assert transforma testes confusos em código limpo e legível.
    
    \item \textbf{Simplicidade é crucial:} A eliminação de lógica condicional e loops torna os testes mais previsíveis e confiáveis.
    
    \item \textbf{Testes são ativos de longo prazo:} Investir em testes limpos reduz significativamente o custo de manutenção ao longo do ciclo de vida do software.
\end{enumerate}

\subsection{Impacto na Sustentabilidade do Software}

A refatoração realizada contribui para a sustentabilidade do projeto de várias formas:

\begin{itemize}
    \item \textbf{Redução de falsos positivos/negativos:} Testes mais precisos aumentam a confiança na suíte
    \item \textbf{Facilitação de refatorações futuras:} Testes robustos permitem mudanças com segurança
    \item \textbf{Onboarding mais rápido:} Novos desenvolvedores entendem o sistema através dos testes
    \item \textbf{Documentação viva:} Os testes descrevem o comportamento esperado do sistema
    \item \textbf{Menor custo de manutenção:} Código limpo é mais barato de manter
\end{itemize}

\subsection{Considerações Finais}

A combinação de análise manual, ferramentas automatizadas e aplicação rigorosa de boas práticas demonstrou ser extremamente eficaz na melhoria da qualidade dos testes. O ESLint, configurado adequadamente, automatiza a detecção de problemas comuns, enquanto a aplicação consciente de padrões como AAA garante testes claros, concisos e efetivos.

Este trabalho reforça a importância de tratar testes como código de produção, merecendo o mesmo nível de cuidado, revisão e refatoração que o código funcional. Testes limpos não são apenas uma boa prática, são essenciais para a qualidade e sustentabilidade de qualquer projeto de software.

\newpage

% Referências
\section{Referências}

\begin{itemize}
    \item FOWLER, Martin. TestSmell. Disponível em: \url{https://martinfowler.com/bliki/TestSmell.html}. Acesso em: 02 nov. 2025.
    
    \item JEST COMMUNITY. eslint-plugin-jest. GitHub. Disponível em: \url{https://github.com/jest-community/eslint-plugin-jest}. Acesso em: 02 nov. 2025.
    
    \item MESZAROS, Gerard. xUnit Test Patterns: Refactoring Test Code. Addison-Wesley Professional, 2007.
    
    \item VAN DEURSEN, Arie et al. Refactoring Test Code. In: Proceedings of the 2nd International Conference on Extreme Programming and Flexible Processes in Software Engineering (XP2001), 2001.
    
    \item Repositório do projeto: \url{https://github.com/LuizNeryy/test-smelly}
\end{itemize}

\end{document}
